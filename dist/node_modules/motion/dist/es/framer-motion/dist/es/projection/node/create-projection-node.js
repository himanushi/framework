import { noop as at } from "../../../../../motion-utils/dist/es/noop.js";
import { getValueTransition as rt } from "../../../../../motion-dom/dist/es/animation/utils/get-value-transition.js";
import { animateSingleValue as nt } from "../../animation/animate/single-value.js";
import { getOptimisedAppearId as lt } from "../../animation/optimized-appear/get-appear-id.js";
import { cancelFrame as M, frameData as g, frameSteps as C, frame as U } from "../../frameloop/frame.js";
import { microtask as ht } from "../../frameloop/microtask.js";
import { time as ut } from "../../frameloop/sync-time.js";
import { isSVGElement as ct } from "../../render/dom/utils/is-svg-element.js";
import { FlatTree as dt } from "../../render/utils/flat-tree.js";
import { clamp as ft } from "../../utils/clamp.js";
import { delay as mt } from "../../utils/delay.js";
import { mixNumber as w } from "../../utils/mix/number.js";
import { SubscriptionManager as pt } from "../../utils/subscription-manager.js";
import { resolveMotionValue as F } from "../../value/utils/resolve-motion-value.js";
import { mixValues as yt } from "../animation/mix-values.js";
import { copyBoxInto as y, copyAxisDeltaInto as z } from "../geometry/copy.js";
import { translateAxis as L, transformBox as E, applyBoxDelta as gt, applyTreeDeltas as vt } from "../geometry/delta-apply.js";
import { calcLength as B, calcRelativePosition as V, calcRelativeBox as Tt, calcBoxDelta as k, isNear as xt } from "../geometry/delta-calc.js";
import { removeBoxTransforms as N } from "../geometry/delta-remove.js";
import { createBox as f, createDelta as A } from "../geometry/models.js";
import { boxEqualsRounded as et, isDeltaZero as it, axisDeltaEquals as _, boxEquals as Dt, aspectRatio as W } from "../geometry/utils.js";
import { NodeStack as St } from "../shared/stack.js";
import { scaleCorrectors as H } from "../styles/scale-correction.js";
import { buildProjectionTransform as Pt } from "../styles/transform.js";
import { eachAxis as q } from "../utils/each-axis.js";
import { hasTransform as P, hasScale as G, has2DTranslate as Bt } from "../utils/has-transform.js";
import { globalProjectionState as O } from "./state.js";
const b = ["", "X", "Y", "Z"], At = { visibility: "hidden" }, X = 1e3;
let jt = 0;
function I(e, l, h, c) {
  const { latestValues: v } = l;
  v[e] && (h[e] = v[e], l.setStaticValue(e, 0), c && (c[e] = 0));
}
function st(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: l } = e.options;
  if (!l)
    return;
  const h = lt(l);
  if (window.MotionHasOptimisedAnimation(h, "transform")) {
    const { layout: v, layoutId: j } = e.options;
    window.MotionCancelOptimisedAnimation(h, "transform", U, !(v || j));
  }
  const { parent: c } = e;
  c && !c.hasCheckedOptimisedAppear && st(c);
}
function ge({ attachResizeListener: e, defaultParent: l, measureScroll: h, checkIsScrollRoot: c, resetTransform: v }) {
  return class {
    constructor(t = {}, i = l == null ? void 0 : l()) {
      this.id = jt++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(kt), this.nodes.forEach(Ct), this.nodes.forEach(Ft), this.nodes.forEach(Lt);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = t, this.root = i ? i.root || i : this, this.path = i ? [...i.path, i] : [], this.parent = i, this.depth = i ? i.depth + 1 : 0;
      for (let s = 0; s < this.path.length; s++)
        this.path[s].shouldResetTransform = !0;
      this.root === this && (this.nodes = new dt());
    }
    addEventListener(t, i) {
      return this.eventHandlers.has(t) || this.eventHandlers.set(t, new pt()), this.eventHandlers.get(t).add(i);
    }
    notifyListeners(t, ...i) {
      const s = this.eventHandlers.get(t);
      s && s.notify(...i);
    }
    hasListeners(t) {
      return this.eventHandlers.has(t);
    }
    /**
     * Lifecycles
     */
    mount(t, i = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = ct(t), this.instance = t;
      const { layoutId: s, layout: o, visualElement: a } = this.options;
      if (a && !a.current && a.mount(t), this.root.nodes.add(this), this.parent && this.parent.children.add(this), i && (o || s) && (this.isLayoutDirty = !0), e) {
        let r;
        const n = () => this.root.updateBlockedByResize = !1;
        e(t, () => {
          this.root.updateBlockedByResize = !0, r && r(), r = mt(n, 250), O.hasAnimatedSinceResize && (O.hasAnimatedSinceResize = !1, this.nodes.forEach($));
        });
      }
      s && this.root.registerSharedNode(s, this), this.options.animate !== !1 && a && (s || o) && this.addEventListener("didUpdate", ({ delta: r, hasLayoutChanged: n, hasRelativeLayoutChanged: u, layout: m }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const d = this.options.transition || a.getDefaultTransition() || zt, { onLayoutAnimationStart: S, onLayoutAnimationComplete: x } = a.getProps(), R = !this.targetLayout || !et(this.targetLayout, m), p = !n && u;
        if (this.options.layoutRoot || this.resumeFrom || p || n && (R || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(r, p);
          const D = {
            ...rt(d, "layout"),
            onPlay: S,
            onComplete: x
          };
          (a.shouldReduceMotion || this.options.layoutRoot) && (D.delay = 0, D.type = !1), this.startAnimation(D);
        } else
          n || $(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = m;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const t = this.getStack();
      t && t.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, M(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Ot), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: t } = this.options;
      return t && t.getProps().transformTemplate;
    }
    willUpdate(t = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && st(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let a = 0; a < this.path.length; a++) {
        const r = this.path[a];
        r.shouldResetTransform = !0, r.updateScroll("snapshot"), r.options.layoutRoot && r.willUpdate(!1);
      }
      const { layoutId: i, layout: s } = this.options;
      if (i === void 0 && !s)
        return;
      const o = this.getTransformTemplate();
      this.prevTransformTemplateValue = o ? o(this.latestValues, "") : void 0, this.updateSnapshot(), t && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Y);
        return;
      }
      this.isUpdating || this.nodes.forEach(Ut), this.isUpdating = !1, this.nodes.forEach(wt), this.nodes.forEach(Rt), this.nodes.forEach(Vt), this.clearAllSnapshots();
      const i = ut.now();
      g.delta = ft(0, 1e3 / 60, i - g.timestamp), g.timestamp = i, g.isProcessing = !0, C.update.process(g), C.preRender.process(g), C.render.process(g), g.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, ht.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(Et), this.sharedNodes.forEach(bt);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, U.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      U.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !B(this.snapshot.measuredBox.x) && !B(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let s = 0; s < this.path.length; s++)
          this.path[s].updateScroll();
      const t = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = f(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: i } = this.options;
      i && i.notify("LayoutMeasure", this.layout.layoutBox, t ? t.layoutBox : void 0);
    }
    updateScroll(t = "measure") {
      let i = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === t && (i = !1), i) {
        const s = c(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: t,
          isRoot: s,
          offset: h(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : s
        };
      }
    }
    resetTransform() {
      if (!v)
        return;
      const t = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, i = this.projectionDelta && !it(this.projectionDelta), s = this.getTransformTemplate(), o = s ? s(this.latestValues, "") : void 0, a = o !== this.prevTransformTemplateValue;
      t && (i || P(this.latestValues) || a) && (v(this.instance, o), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(t = !0) {
      const i = this.measurePageBox();
      let s = this.removeElementScroll(i);
      return t && (s = this.removeTransform(s)), Nt(s), {
        animationId: this.root.animationId,
        measuredBox: i,
        layoutBox: s,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var t;
      const { visualElement: i } = this.options;
      if (!i)
        return f();
      const s = i.measureViewportBox();
      if (!(((t = this.scroll) === null || t === void 0 ? void 0 : t.wasRoot) || this.path.some(_t))) {
        const { scroll: a } = this.root;
        a && (L(s.x, a.offset.x), L(s.y, a.offset.y));
      }
      return s;
    }
    removeElementScroll(t) {
      var i;
      const s = f();
      if (y(s, t), !((i = this.scroll) === null || i === void 0) && i.wasRoot)
        return s;
      for (let o = 0; o < this.path.length; o++) {
        const a = this.path[o], { scroll: r, options: n } = a;
        a !== this.root && r && n.layoutScroll && (r.wasRoot && y(s, t), L(s.x, r.offset.x), L(s.y, r.offset.y));
      }
      return s;
    }
    applyTransform(t, i = !1) {
      const s = f();
      y(s, t);
      for (let o = 0; o < this.path.length; o++) {
        const a = this.path[o];
        !i && a.options.layoutScroll && a.scroll && a !== a.root && E(s, {
          x: -a.scroll.offset.x,
          y: -a.scroll.offset.y
        }), P(a.latestValues) && E(s, a.latestValues);
      }
      return P(this.latestValues) && E(s, this.latestValues), s;
    }
    removeTransform(t) {
      const i = f();
      y(i, t);
      for (let s = 0; s < this.path.length; s++) {
        const o = this.path[s];
        if (!o.instance || !P(o.latestValues))
          continue;
        G(o.latestValues) && o.updateSnapshot();
        const a = f(), r = o.measurePageBox();
        y(a, r), N(i, o.latestValues, o.snapshot ? o.snapshot.layoutBox : void 0, a);
      }
      return P(this.latestValues) && N(i, this.latestValues), i;
    }
    setTargetDelta(t) {
      this.targetDelta = t, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(t) {
      this.options = {
        ...this.options,
        ...t,
        crossfade: t.crossfade !== void 0 ? t.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== g.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(t = !1) {
      var i;
      const s = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = s.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = s.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = s.isSharedProjectionDirty);
      const o = !!this.resumingFrom || this !== s;
      if (!(t || o && this.isSharedProjectionDirty || this.isProjectionDirty || !((i = this.parent) === null || i === void 0) && i.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: r, layoutId: n } = this.options;
      if (!(!this.layout || !(r || n))) {
        if (this.resolvedRelativeTargetAt = g.timestamp, !this.targetDelta && !this.relativeTarget) {
          const u = this.getClosestProjectingParent();
          u && u.layout && this.animationProgress !== 1 ? (this.relativeParent = u, this.forceRelativeParentToResolveTarget(), this.relativeTarget = f(), this.relativeTargetOrigin = f(), V(this.relativeTargetOrigin, this.layout.layoutBox, u.layout.layoutBox), y(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = f(), this.targetWithTransforms = f()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Tt(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : y(this.target, this.layout.layoutBox), gt(this.target, this.targetDelta)) : y(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
          this.attemptToResolveRelativeTarget = !1;
          const u = this.getClosestProjectingParent();
          u && !!u.resumingFrom == !!this.resumingFrom && !u.options.layoutScroll && u.target && this.animationProgress !== 1 ? (this.relativeParent = u, this.forceRelativeParentToResolveTarget(), this.relativeTarget = f(), this.relativeTargetOrigin = f(), V(this.relativeTargetOrigin, this.target, u.target), y(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || G(this.parent.latestValues) || Bt(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var t;
      const i = this.getLead(), s = !!this.resumingFrom || this !== i;
      let o = !0;
      if ((this.isProjectionDirty || !((t = this.parent) === null || t === void 0) && t.isProjectionDirty) && (o = !1), s && (this.isSharedProjectionDirty || this.isTransformDirty) && (o = !1), this.resolvedRelativeTargetAt === g.timestamp && (o = !1), o)
        return;
      const { layout: a, layoutId: r } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(a || r))
        return;
      y(this.layoutCorrected, this.layout.layoutBox);
      const n = this.treeScale.x, u = this.treeScale.y;
      vt(this.layoutCorrected, this.treeScale, this.path, s), i.layout && !i.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (i.target = i.layout.layoutBox, i.targetWithTransforms = f());
      const { target: m } = i;
      if (!m) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (z(this.prevProjectionDelta.x, this.projectionDelta.x), z(this.prevProjectionDelta.y, this.projectionDelta.y)), k(this.projectionDelta, this.layoutCorrected, m, this.latestValues), (this.treeScale.x !== n || this.treeScale.y !== u || !_(this.projectionDelta.x, this.prevProjectionDelta.x) || !_(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", m));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(t = !0) {
      var i;
      if ((i = this.options.visualElement) === null || i === void 0 || i.scheduleRender(), t) {
        const s = this.getStack();
        s && s.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = A(), this.projectionDelta = A(), this.projectionDeltaWithTransform = A();
    }
    setAnimationOrigin(t, i = !1) {
      const s = this.snapshot, o = s ? s.latestValues : {}, a = { ...this.latestValues }, r = A();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !i;
      const n = f(), u = s ? s.source : void 0, m = this.layout ? this.layout.source : void 0, d = u !== m, S = this.getStack(), x = !S || S.members.length <= 1, R = !!(d && !x && this.options.crossfade === !0 && !this.path.some(Mt));
      this.animationProgress = 0;
      let p;
      this.mixTargetDelta = (D) => {
        const T = D / 1e3;
        Z(r.x, t.x, T), Z(r.y, t.y, T), this.setTargetDelta(r), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (V(n, this.layout.layoutBox, this.relativeParent.layout.layoutBox), It(this.relativeTarget, this.relativeTargetOrigin, n, T), p && Dt(this.relativeTarget, p) && (this.isProjectionDirty = !1), p || (p = f()), y(p, this.relativeTarget)), d && (this.animationValues = a, yt(a, o, this.latestValues, T, R, x)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = T;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(t) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (M(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = U.update(() => {
        O.hasAnimatedSinceResize = !0, this.currentAnimation = nt(0, X, {
          ...t,
          onUpdate: (i) => {
            this.mixTargetDelta(i), t.onUpdate && t.onUpdate(i);
          },
          onStop: () => {
          },
          onComplete: () => {
            t.onComplete && t.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const t = this.getStack();
      t && t.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(X), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const t = this.getLead();
      let { targetWithTransforms: i, target: s, layout: o, latestValues: a } = t;
      if (!(!i || !s || !o)) {
        if (this !== t && this.layout && o && ot(this.options.animationType, this.layout.layoutBox, o.layoutBox)) {
          s = this.target || f();
          const r = B(this.layout.layoutBox.x);
          s.x.min = t.target.x.min, s.x.max = s.x.min + r;
          const n = B(this.layout.layoutBox.y);
          s.y.min = t.target.y.min, s.y.max = s.y.min + n;
        }
        y(i, s), E(i, a), k(this.projectionDeltaWithTransform, this.layoutCorrected, i, a);
      }
    }
    registerSharedNode(t, i) {
      this.sharedNodes.has(t) || this.sharedNodes.set(t, new St()), this.sharedNodes.get(t).add(i);
      const o = i.options.initialPromotionConfig;
      i.promote({
        transition: o ? o.transition : void 0,
        preserveFollowOpacity: o && o.shouldPreserveFollowOpacity ? o.shouldPreserveFollowOpacity(i) : void 0
      });
    }
    isLead() {
      const t = this.getStack();
      return t ? t.lead === this : !0;
    }
    getLead() {
      var t;
      const { layoutId: i } = this.options;
      return i ? ((t = this.getStack()) === null || t === void 0 ? void 0 : t.lead) || this : this;
    }
    getPrevLead() {
      var t;
      const { layoutId: i } = this.options;
      return i ? (t = this.getStack()) === null || t === void 0 ? void 0 : t.prevLead : void 0;
    }
    getStack() {
      const { layoutId: t } = this.options;
      if (t)
        return this.root.sharedNodes.get(t);
    }
    promote({ needsReset: t, transition: i, preserveFollowOpacity: s } = {}) {
      const o = this.getStack();
      o && o.promote(this, s), t && (this.projectionDelta = void 0, this.needsReset = !0), i && this.setOptions({ transition: i });
    }
    relegate() {
      const t = this.getStack();
      return t ? t.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: t } = this.options;
      if (!t)
        return;
      let i = !1;
      const { latestValues: s } = t;
      if ((s.z || s.rotate || s.rotateX || s.rotateY || s.rotateZ || s.skewX || s.skewY) && (i = !0), !i)
        return;
      const o = {};
      s.z && I("z", t, o, this.animationValues);
      for (let a = 0; a < b.length; a++)
        I(`rotate${b[a]}`, t, o, this.animationValues), I(`skew${b[a]}`, t, o, this.animationValues);
      t.render();
      for (const a in o)
        t.setStaticValue(a, o[a]), this.animationValues && (this.animationValues[a] = o[a]);
      t.scheduleRender();
    }
    getProjectionStyles(t) {
      var i, s;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return At;
      const o = {
        visibility: ""
      }, a = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, o.opacity = "", o.pointerEvents = F(t == null ? void 0 : t.pointerEvents) || "", o.transform = a ? a(this.latestValues, "") : "none", o;
      const r = this.getLead();
      if (!this.projectionDelta || !this.layout || !r.target) {
        const d = {};
        return this.options.layoutId && (d.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, d.pointerEvents = F(t == null ? void 0 : t.pointerEvents) || ""), this.hasProjected && !P(this.latestValues) && (d.transform = a ? a({}, "") : "none", this.hasProjected = !1), d;
      }
      const n = r.animationValues || r.latestValues;
      this.applyTransformsToTarget(), o.transform = Pt(this.projectionDeltaWithTransform, this.treeScale, n), a && (o.transform = a(n, o.transform));
      const { x: u, y: m } = this.projectionDelta;
      o.transformOrigin = `${u.origin * 100}% ${m.origin * 100}% 0`, r.animationValues ? o.opacity = r === this ? (s = (i = n.opacity) !== null && i !== void 0 ? i : this.latestValues.opacity) !== null && s !== void 0 ? s : 1 : this.preserveOpacity ? this.latestValues.opacity : n.opacityExit : o.opacity = r === this ? n.opacity !== void 0 ? n.opacity : "" : n.opacityExit !== void 0 ? n.opacityExit : 0;
      for (const d in H) {
        if (n[d] === void 0)
          continue;
        const { correct: S, applyTo: x, isCSSVariable: R } = H[d], p = o.transform === "none" ? n[d] : S(n[d], r);
        if (x) {
          const D = x.length;
          for (let T = 0; T < D; T++)
            o[x[T]] = p;
        } else
          R ? this.options.visualElement.renderState.vars[d] = p : o[d] = p;
      }
      return this.options.layoutId && (o.pointerEvents = r === this ? F(t == null ? void 0 : t.pointerEvents) || "" : "none"), o;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((t) => {
        var i;
        return (i = t.currentAnimation) === null || i === void 0 ? void 0 : i.stop();
      }), this.root.nodes.forEach(Y), this.root.sharedNodes.clear();
    }
  };
}
function Rt(e) {
  e.updateLayout();
}
function Vt(e) {
  var l;
  const h = ((l = e.resumeFrom) === null || l === void 0 ? void 0 : l.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && h && e.hasListeners("didUpdate")) {
    const { layoutBox: c, measuredBox: v } = e.layout, { animationType: j } = e.options, t = h.source !== e.layout.source;
    j === "size" ? q((r) => {
      const n = t ? h.measuredBox[r] : h.layoutBox[r], u = B(n);
      n.min = c[r].min, n.max = n.min + u;
    }) : ot(j, h.layoutBox, c) && q((r) => {
      const n = t ? h.measuredBox[r] : h.layoutBox[r], u = B(c[r]);
      n.max = n.min + u, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[r].max = e.relativeTarget[r].min + u);
    });
    const i = A();
    k(i, c, h.layoutBox);
    const s = A();
    t ? k(s, e.applyTransform(v, !0), h.measuredBox) : k(s, c, h.layoutBox);
    const o = !it(i);
    let a = !1;
    if (!e.resumeFrom) {
      const r = e.getClosestProjectingParent();
      if (r && !r.resumeFrom) {
        const { snapshot: n, layout: u } = r;
        if (n && u) {
          const m = f();
          V(m, h.layoutBox, n.layoutBox);
          const d = f();
          V(d, c, u.layoutBox), et(m, d) || (a = !0), r.options.layoutRoot && (e.relativeTarget = d, e.relativeTargetOrigin = m, e.relativeParent = r);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: c,
      snapshot: h,
      delta: s,
      layoutDelta: i,
      hasLayoutChanged: o,
      hasRelativeLayoutChanged: a
    });
  } else if (e.isLead()) {
    const { onExitComplete: c } = e.options;
    c && c();
  }
  e.options.transition = void 0;
}
function kt(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function Lt(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function Et(e) {
  e.clearSnapshot();
}
function Y(e) {
  e.clearMeasurements();
}
function Ut(e) {
  e.isLayoutDirty = !1;
}
function wt(e) {
  const { visualElement: l } = e.options;
  l && l.getProps().onBeforeLayoutMeasure && l.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function $(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function Ct(e) {
  e.resolveTargetDelta();
}
function Ft(e) {
  e.calcProjection();
}
function Ot(e) {
  e.resetSkewAndRotation();
}
function bt(e) {
  e.removeLeadSnapshot();
}
function Z(e, l, h) {
  e.translate = w(l.translate, 0, h), e.scale = w(l.scale, 1, h), e.origin = l.origin, e.originPoint = l.originPoint;
}
function J(e, l, h, c) {
  e.min = w(l.min, h.min, c), e.max = w(l.max, h.max, c);
}
function It(e, l, h, c) {
  J(e.x, l.x, h.x, c), J(e.y, l.y, h.y, c);
}
function Mt(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const zt = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, K = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), Q = K("applewebkit/") && !K("chrome/") ? Math.round : at;
function tt(e) {
  e.min = Q(e.min), e.max = Q(e.max);
}
function Nt(e) {
  tt(e.x), tt(e.y);
}
function ot(e, l, h) {
  return e === "position" || e === "preserve-aspect" && !xt(W(l), W(h), 0.2);
}
function _t(e) {
  var l;
  return e !== e.root && ((l = e.scroll) === null || l === void 0 ? void 0 : l.wasRoot);
}
export {
  Lt as cleanDirtyNodes,
  ge as createProjectionNode,
  J as mixAxis,
  Z as mixAxisDelta,
  It as mixBox,
  kt as propagateDirtyNodes
};
