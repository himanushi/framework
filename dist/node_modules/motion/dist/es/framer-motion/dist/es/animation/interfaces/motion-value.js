import { GroupPlaybackControls as c } from "../../../../../motion-dom/dist/es/animation/controls/Group.js";
import { getValueTransition as D } from "../../../../../motion-dom/dist/es/animation/utils/get-value-transition.js";
import { secondsToMilliseconds as f } from "../../../../../motion-utils/dist/es/time-conversion.js";
import { frame as T } from "../../frameloop/frame.js";
import { AcceleratedAnimation as d } from "../animators/AcceleratedAnimation.js";
import { MainThreadAnimation as k } from "../animators/MainThreadAnimation.js";
import { getFinalKeyframe as A } from "../animators/waapi/utils/get-final-keyframe.js";
import { getDefaultTransition as C } from "../utils/default-transitions.js";
import { isTransitionDefined as U } from "../utils/is-transition-defined.js";
const G = (i, r, n, a = {}, s, l) => (u) => {
  const o = D(a, i) || {}, y = o.delay || a.delay || 0;
  let { elapsed: m = 0 } = a;
  m = m - f(y);
  let e = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: r.getVelocity(),
    ...o,
    delay: -m,
    onUpdate: (t) => {
      r.set(t), o.onUpdate && o.onUpdate(t);
    },
    onComplete: () => {
      u(), o.onComplete && o.onComplete();
    },
    name: i,
    motionValue: r,
    element: l ? void 0 : s
  };
  U(o) || (e = {
    ...e,
    ...C(i, e)
  }), e.duration && (e.duration = f(e.duration)), e.repeatDelay && (e.repeatDelay = f(e.repeatDelay)), e.from !== void 0 && (e.keyframes[0] = e.from);
  let p = !1;
  if ((e.type === !1 || e.duration === 0 && !e.repeatDelay) && (e.duration = 0, e.delay === 0 && (p = !0)), p && !l && r.get() !== void 0) {
    const t = A(e.keyframes, o);
    if (t !== void 0)
      return T.update(() => {
        e.onUpdate(t), e.onComplete();
      }), new c([]);
  }
  return !l && d.supports(e) ? new d(e) : new k(e);
};
export {
  G as animateMotionValue
};
