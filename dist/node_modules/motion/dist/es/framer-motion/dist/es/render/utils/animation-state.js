import { animateVisualElement as j } from "../../animation/interfaces/visual-element.js";
import { isAnimationControls as q } from "../../animation/utils/is-animation-controls.js";
import { isKeyframesTarget as D } from "../../animation/utils/is-keyframes-target.js";
import { shallowCompare as k } from "../../utils/shallow-compare.js";
import { getVariantContext as G } from "./get-variant-context.js";
import { isVariantLabel as J } from "./is-variant-label.js";
import { resolveVariant as L } from "./resolve-dynamic-variants.js";
import { variantPriorityOrder as B } from "./variant-props.js";
const N = [...B].reverse(), Q = B.length;
function U(e) {
  return (f) => Promise.all(f.map(({ animation: c, options: v }) => j(e, c, v)));
}
function oe(e) {
  let f = U(e), c = _(), v = !0;
  const F = (s) => (t, p) => {
    var l;
    const r = L(e, p, s === "exit" ? (l = e.presenceContext) === null || l === void 0 ? void 0 : l.custom : void 0);
    if (r) {
      const { transition: u, transitionEnd: y, ...g } = r;
      t = { ...t, ...g, ...y };
    }
    return t;
  };
  function H(s) {
    f = s(e);
  }
  function K(s) {
    const { props: t } = e, p = G(e.parent) || {}, l = [], r = /* @__PURE__ */ new Set();
    let u = {}, y = 1 / 0;
    for (let d = 0; d < Q; d++) {
      const i = N[d], n = c[i], o = t[i] !== void 0 ? t[i] : p[i], w = J(o), P = i === s ? n.isActive : null;
      P === !1 && (y = d);
      let V = o === p[i] && o !== t[i] && w;
      if (V && v && e.manuallyAnimateOnMount && (V = !1), n.protectedKeys = { ...u }, // If it isn't active and hasn't *just* been set as inactive
      !n.isActive && P === null || // If we didn't and don't have any defined prop for this animation type
      !o && !n.prevProp || // Or if the prop doesn't define an animation
      q(o) || typeof o == "boolean")
        continue;
      const b = W(n.prevProp, o);
      let C = b || // If we're making this variant active, we want to always make it active
      i === s && n.isActive && !V && w || // If we removed a higher-priority variant (i is in reverse order)
      d > y && w, I = !1;
      const R = Array.isArray(o) ? o : [o];
      let h = R.reduce(F(i), {});
      P === !1 && (h = {});
      const { prevResolvedValues: x = {} } = n, z = {
        ...x,
        ...h
      }, O = (a) => {
        C = !0, r.has(a) && (I = !0, r.delete(a)), n.needsAnimating[a] = !0;
        const m = e.getValue(a);
        m && (m.liveStyle = !1);
      };
      for (const a in z) {
        const m = h[a], S = x[a];
        if (u.hasOwnProperty(a))
          continue;
        let T = !1;
        D(m) && D(S) ? T = !k(m, S) : T = m !== S, T ? m != null ? O(a) : r.add(a) : m !== void 0 && r.has(a) ? O(a) : n.protectedKeys[a] = !0;
      }
      n.prevProp = o, n.prevResolvedValues = h, n.isActive && (u = { ...u, ...h }), v && e.blockInitialAnimation && (C = !1), C && (!(V && b) || I) && l.push(...R.map((a) => ({
        animation: a,
        options: { type: i }
      })));
    }
    if (r.size) {
      const d = {};
      if (typeof t.initial != "boolean") {
        const i = L(e, Array.isArray(t.initial) ? t.initial[0] : t.initial);
        i && i.transition && (d.transition = i.transition);
      }
      r.forEach((i) => {
        const n = e.getBaseTarget(i), o = e.getValue(i);
        o && (o.liveStyle = !0), d[i] = n ?? null;
      }), l.push({ animation: d });
    }
    let g = !!l.length;
    return v && (t.initial === !1 || t.initial === t.animate) && !e.manuallyAnimateOnMount && (g = !1), v = !1, g ? f(l) : Promise.resolve();
  }
  function M(s, t) {
    var p;
    if (c[s].isActive === t)
      return Promise.resolve();
    (p = e.variantChildren) === null || p === void 0 || p.forEach((r) => {
      var u;
      return (u = r.animationState) === null || u === void 0 ? void 0 : u.setActive(s, t);
    }), c[s].isActive = t;
    const l = K(s);
    for (const r in c)
      c[r].protectedKeys = {};
    return l;
  }
  return {
    animateChanges: K,
    setActive: M,
    setAnimateFunction: H,
    getState: () => c,
    reset: () => {
      c = _(), v = !0;
    }
  };
}
function W(e, f) {
  return typeof f == "string" ? f !== e : Array.isArray(f) ? !k(f, e) : !1;
}
function A(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function _() {
  return {
    animate: A(!0),
    whileInView: A(),
    whileHover: A(),
    whileTap: A(),
    whileDrag: A(),
    whileFocus: A(),
    exit: A()
  };
}
export {
  W as checkVariantsDidChange,
  oe as createAnimationState
};
