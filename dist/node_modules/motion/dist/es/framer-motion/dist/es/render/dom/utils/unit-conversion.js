import { number as l } from "../../../value/types/numbers/index.js";
import { px as p } from "../../../value/types/numbers/units.js";
import { transformPropOrder as x } from "../../html/utils/keys-transform.js";
const b = (t) => t === l || t === p, i = (t, r) => parseFloat(t.split(", ")[r]), m = (t, r) => (a, { transform: o }) => {
  if (o === "none" || !o)
    return 0;
  const s = o.match(/^matrix3d\((.+)\)$/u);
  if (s)
    return i(s[1], r);
  {
    const n = o.match(/^matrix\((.+)\)$/u);
    return n ? i(n[1], t) : 0;
  }
}, c = /* @__PURE__ */ new Set(["x", "y", "z"]), u = x.filter((t) => !c.has(t));
function d(t) {
  const r = [];
  return u.forEach((a) => {
    const o = t.getValue(a);
    o !== void 0 && (r.push([a, o.get()]), o.set(a.startsWith("scale") ? 1 : 0));
  }), r;
}
const e = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: r = "0", paddingRight: a = "0" }) => t.max - t.min - parseFloat(r) - parseFloat(a),
  height: ({ y: t }, { paddingTop: r = "0", paddingBottom: a = "0" }) => t.max - t.min - parseFloat(r) - parseFloat(a),
  top: (t, { top: r }) => parseFloat(r),
  left: (t, { left: r }) => parseFloat(r),
  bottom: ({ y: t }, { top: r }) => parseFloat(r) + (t.max - t.min),
  right: ({ x: t }, { left: r }) => parseFloat(r) + (t.max - t.min),
  // Transform
  x: m(4, 13),
  y: m(5, 14)
};
e.translateX = e.x;
e.translateY = e.y;
export {
  b as isNumOrPxType,
  e as positionalValues,
  d as removeNonTranslationalTransform
};
