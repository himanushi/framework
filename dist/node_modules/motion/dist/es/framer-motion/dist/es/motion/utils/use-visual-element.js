import { useContext as f, useRef as C, useInsertionEffect as j, useEffect as I } from "react";
import { PresenceContext as h } from "../../context/PresenceContext.js";
import { MotionContext as A } from "../../context/MotionContext/index.js";
import { useIsomorphicLayoutEffect as S } from "../../utils/use-isomorphic-effect.js";
import { LazyContext as b } from "../../context/LazyContext.js";
import { MotionConfigContext as v } from "../../context/MotionConfigContext.js";
import { optimizedAppearDataAttribute as L } from "../../animation/optimized-appear/data-id.js";
import { microtask as k } from "../../frameloop/microtask.js";
import { isRefObject as H } from "../../utils/is-ref-object.js";
import { SwitchLayoutGroupContext as R } from "../../context/SwitchLayoutGroupContext.js";
function J(o, u, e, i, c) {
  var n, a;
  const { visualElement: s } = f(A), l = f(b), r = f(h), g = f(v).reducedMotion, d = C(null);
  i = i || l.renderer, !d.current && i && (d.current = i(o, {
    visualState: u,
    parent: s,
    props: e,
    presenceContext: r,
    blockInitialAnimation: r ? r.initial === !1 : !1,
    reducedMotionConfig: g
  }));
  const t = d.current, x = f(R);
  t && !t.projection && c && (t.type === "html" || t.type === "svg") && z(d.current, e, c, x);
  const y = C(!1);
  j(() => {
    t && y.current && t.update(e, r);
  });
  const m = e[L], p = C(!!m && !(!((n = window.MotionHandoffIsComplete) === null || n === void 0) && n.call(window, m)) && ((a = window.MotionHasOptimisedAnimation) === null || a === void 0 ? void 0 : a.call(window, m)));
  return S(() => {
    t && (y.current = !0, window.MotionIsMounted = !0, t.updateFeatures(), k.render(t.render), p.current && t.animationState && t.animationState.animateChanges());
  }), I(() => {
    t && (!p.current && t.animationState && t.animationState.animateChanges(), p.current && (queueMicrotask(() => {
      var w;
      (w = window.MotionHandoffMarkAsComplete) === null || w === void 0 || w.call(window, m);
    }), p.current = !1));
  }), t;
}
function z(o, u, e, i) {
  const { layoutId: c, layout: n, drag: a, dragConstraints: s, layoutScroll: l, layoutRoot: r } = u;
  o.projection = new e(o.latestValues, u["data-framer-portal-id"] ? void 0 : M(o.parent)), o.projection.setOptions({
    layoutId: c,
    layout: n,
    alwaysMeasureLayout: !!a || s && H(s),
    visualElement: o,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof n == "string" ? n : "both",
    initialPromotionConfig: i,
    layoutScroll: l,
    layoutRoot: r
  });
}
function M(o) {
  if (o)
    return o.options.allowProjection !== !1 ? o.projection : M(o.parent);
}
export {
  J as useVisualElement
};
