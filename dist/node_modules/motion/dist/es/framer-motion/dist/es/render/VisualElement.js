import { time as g } from "../frameloop/sync-time.js";
import { featureDefinitions as d } from "../motion/features/definitions.js";
import { createBox as M } from "../projection/geometry/models.js";
import { isNumericalString as S } from "../utils/is-numerical-string.js";
import { isZeroValueString as C } from "../utils/is-zero-value-string.js";
import { initPrefersReducedMotion as b } from "../utils/reduced-motion/index.js";
import { hasReducedMotionListener as T, prefersReducedMotion as P } from "../utils/reduced-motion/state.js";
import { SubscriptionManager as w } from "../utils/subscription-manager.js";
import { warnOnce as F } from "../utils/warn-once.js";
import { motionValue as R } from "../value/index.js";
import { complex as B } from "../value/types/complex/index.js";
import { isMotionValue as h } from "../value/utils/is-motion-value.js";
import { getAnimatableNone as N } from "./dom/value-types/animatable-none.js";
import { findValueType as E } from "./dom/value-types/find.js";
import { transformProps as x } from "./html/utils/keys-transform.js";
import { visualElementStore as A } from "./store.js";
import { isControllingVariants as U, isVariantNode as j } from "./utils/is-controlling-variants.js";
import { KeyframeResolver as y } from "./utils/KeyframesResolver.js";
import { updateMotionValuesFromProps as I } from "./utils/motion-values.js";
import { resolveVariantFromProps as _ } from "./utils/resolve-variants.js";
import { frame as f, cancelFrame as c } from "../frameloop/frame.js";
const m = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class at {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, e, s) {
    return {};
  }
  constructor({ parent: t, props: e, presenceContext: s, reducedMotionConfig: i, blockInitialAnimation: r, visualState: n }, u = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = y, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const o = g.now();
      this.renderScheduledAt < o && (this.renderScheduledAt = o, f.render(this.render, !1, !0));
    };
    const { latestValues: a, renderState: V, onUpdate: v } = n;
    this.onUpdate = v, this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = e.initial ? { ...a } : {}, this.renderState = V, this.parent = t, this.props = e, this.presenceContext = s, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = u, this.blockInitialAnimation = !!r, this.isControllingVariants = U(e), this.isVariantNode = j(e), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: L, ...l } = this.scrapeMotionValuesFromProps(e, {}, this);
    for (const o in l) {
      const p = l[o];
      a[o] !== void 0 && h(p) && p.set(a[o], !1);
    }
  }
  mount(t) {
    this.current = t, A.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((e, s) => this.bindToMotionValue(s, e)), T.current || b(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : P.current, process.env.NODE_ENV !== "production" && F(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), c(this.notifyUpdate), c(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const e = this.features[t];
      e && (e.unmount(), e.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(t, e) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const s = x.has(t);
    s && this.onBindTransform && this.onBindTransform();
    const i = e.on("change", (u) => {
      this.latestValues[t] = u, this.props.onUpdate && f.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0);
    }), r = e.on("renderRequest", this.scheduleRender);
    let n;
    window.MotionCheckAppearSync && (n = window.MotionCheckAppearSync(this, t, e)), this.valueSubscriptions.set(t, () => {
      i(), r(), n && n(), e.owner && e.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in d) {
      const e = d[t];
      if (!e)
        continue;
      const { isEnabled: s, Feature: i } = e;
      if (!this.features[t] && i && s(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const r = this.features[t];
        r.isMounted ? r.update() : (r.mount(), r.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : M();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, e) {
    this.latestValues[t] = e;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, e) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = e;
    for (let s = 0; s < m.length; s++) {
      const i = m[s];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const r = "on" + i, n = t[r];
      n && (this.propEventSubscriptions[i] = this.on(i, n));
    }
    this.prevMotionValues = I(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this);
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const e = this.getClosestVariantNode();
    if (e)
      return e.variantChildren && e.variantChildren.add(t), () => e.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, e) {
    const s = this.values.get(t);
    e !== s && (s && this.removeValue(t), this.bindToMotionValue(t, e), this.values.set(t, e), this.latestValues[t] = e.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const e = this.valueSubscriptions.get(t);
    e && (e(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, e) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let s = this.values.get(t);
    return s === void 0 && e !== void 0 && (s = R(e === null ? void 0 : e, { owner: this }), this.addValue(t, s)), s;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, e) {
    var s;
    let i = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : (s = this.getBaseTargetFromProps(this.props, t)) !== null && s !== void 0 ? s : this.readValueFromInstance(this.current, t, this.options);
    return i != null && (typeof i == "string" && (S(i) || C(i)) ? i = parseFloat(i) : !E(i) && B.test(e) && (i = N(t, e)), this.setBaseTarget(t, h(i) ? i.get() : i)), h(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, e) {
    this.baseTarget[t] = e;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var e;
    const { initial: s } = this.props;
    let i;
    if (typeof s == "string" || typeof s == "object") {
      const n = _(this.props, s, (e = this.presenceContext) === null || e === void 0 ? void 0 : e.custom);
      n && (i = n[t]);
    }
    if (s && i !== void 0)
      return i;
    const r = this.getBaseTargetFromProps(this.props, t);
    return r !== void 0 && !h(r) ? r : this.initialValues[t] !== void 0 && i === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, e) {
    return this.events[t] || (this.events[t] = new w()), this.events[t].add(e);
  }
  notify(t, ...e) {
    this.events[t] && this.events[t].notify(...e);
  }
}
export {
  at as VisualElement
};
