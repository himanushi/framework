import { millisecondsToSeconds as b, secondsToMilliseconds as R } from "../../../../../../motion-utils/dist/es/time-conversion.js";
import { calcGeneratorDuration as A, maxGeneratorDuration as w } from "../../../../../../motion-dom/dist/es/animation/generators/utils/calc-duration.js";
import { generateLinearEasing as B } from "../../../../../../motion-dom/dist/es/animation/waapi/utils/linear.js";
import { clamp as K } from "../../../utils/clamp.js";
import { calcGeneratorVelocity as V } from "../utils/velocity.js";
import { springDefaults as a } from "./defaults.js";
import { findSpring as j, calcAngularFreq as E } from "./find.js";
const I = ["duration", "bounce"], L = ["stiffness", "damping", "mass"];
function x(t, r) {
  return r.some((s) => t[s] !== void 0);
}
function P(t) {
  let r = {
    velocity: a.velocity,
    stiffness: a.stiffness,
    damping: a.damping,
    mass: a.mass,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!x(t, L) && x(t, I))
    if (t.visualDuration) {
      const s = t.visualDuration, u = 2 * Math.PI / (s * 1.2), m = u * u, g = 2 * K(0.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(m);
      r = {
        ...r,
        mass: a.mass,
        stiffness: m,
        damping: g
      };
    } else {
      const s = j(t);
      r = {
        ...r,
        ...s,
        mass: a.mass
      }, r.isResolvedFromDuration = !0;
    }
  return r;
}
function U(t = a.visualDuration, r = a.bounce) {
  const s = typeof t != "object" ? {
    visualDuration: t,
    keyframes: [0, 1],
    bounce: r
  } : t;
  let { restSpeed: u, restDelta: m } = s;
  const g = s.keyframes[0], f = s.keyframes[s.keyframes.length - 1], d = { done: !1, value: g }, { stiffness: M, damping: T, mass: D, duration: S, velocity: k, isResolvedFromDuration: q } = P({
    ...s,
    velocity: -b(s.velocity || 0)
  }), h = k || 0, o = T / (2 * Math.sqrt(M * D)), c = f - g, i = b(Math.sqrt(M / D)), F = Math.abs(c) < 5;
  u || (u = F ? a.restSpeed.granular : a.restSpeed.default), m || (m = F ? a.restDelta.granular : a.restDelta.default);
  let p;
  if (o < 1) {
    const e = E(i, o);
    p = (n) => {
      const l = Math.exp(-o * i * n);
      return f - l * ((h + o * i * c) / e * Math.sin(e * n) + c * Math.cos(e * n));
    };
  } else if (o === 1)
    p = (e) => f - Math.exp(-i * e) * (c + (h + i * c) * e);
  else {
    const e = i * Math.sqrt(o * o - 1);
    p = (n) => {
      const l = Math.exp(-o * i * n), v = Math.min(e * n, 300);
      return f - l * ((h + o * i * c) * Math.sinh(v) + e * c * Math.cosh(v)) / e;
    };
  }
  const y = {
    calculatedDuration: q && S || null,
    next: (e) => {
      const n = p(e);
      if (q)
        d.done = e >= S;
      else {
        let l = 0;
        o < 1 && (l = e === 0 ? R(h) : V(p, e, n));
        const v = Math.abs(l) <= u, G = Math.abs(f - n) <= m;
        d.done = v && G;
      }
      return d.value = d.done ? f : n, d;
    },
    toString: () => {
      const e = Math.min(A(y), w), n = B((l) => y.next(e * l).value, e, 30);
      return e + "ms " + n;
    }
  };
  return y;
}
export {
  U as spring
};
