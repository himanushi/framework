import { jsxs as E, jsx as x } from "react/jsx-runtime";
import { warning as g, invariant as L } from "../../../../motion-utils/dist/es/errors.js";
import { forwardRef as j, useContext as d } from "react";
import { LayoutGroupContext as N } from "../context/LayoutGroupContext.js";
import { LazyContext as P } from "../context/LazyContext.js";
import { MotionConfigContext as b } from "../context/MotionConfigContext.js";
import { MotionContext as w } from "../context/MotionContext/index.js";
import { useCreateMotionContext as C } from "../context/MotionContext/create.js";
import { isBrowser as S } from "../utils/is-browser.js";
import { featureDefinitions as h } from "./features/definitions.js";
import { loadFeatures as R } from "./features/load-features.js";
import { motionComponentSymbol as _ } from "./utils/symbol.js";
import { useMotionRef as k } from "./utils/use-motion-ref.js";
import { useVisualElement as z } from "./utils/use-visual-element.js";
function W({ preloadedFeatures: o, createVisualElement: t, useRender: e, useVisualState: n, Component: i }) {
  var s, m;
  o && R(o);
  function v(a, p) {
    let c;
    const u = {
      ...d(b),
      ...a,
      layoutId: D(a)
    }, { isStatic: l } = u, r = C(a), f = n(a, l);
    if (!l && S) {
      G(u, o);
      const M = I(u);
      c = M.MeasureLayout, r.visualElement = z(i, f, u, t, M.ProjectionNode);
    }
    return E(w.Provider, { value: r, children: [c && r.visualElement ? x(c, { visualElement: r.visualElement, ...u }) : null, e(i, a, k(f, r.visualElement, p), f, l, r.visualElement)] });
  }
  v.displayName = `motion.${typeof i == "string" ? i : `create(${(m = (s = i.displayName) !== null && s !== void 0 ? s : i.name) !== null && m !== void 0 ? m : ""})`}`;
  const y = j(v);
  return y[_] = i, y;
}
function D({ layoutId: o }) {
  const t = d(N).id;
  return t && o !== void 0 ? t + "-" + o : o;
}
function G(o, t) {
  const e = d(P).strict;
  if (process.env.NODE_ENV !== "production" && t && e) {
    const n = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    o.ignoreStrict ? g(!1, n) : L(!1, n);
  }
}
function I(o) {
  const { drag: t, layout: e } = h;
  if (!t && !e)
    return {};
  const n = { ...t, ...e };
  return {
    MeasureLayout: t != null && t.isEnabled(o) || e != null && e.isEnabled(o) ? n.MeasureLayout : void 0,
    ProjectionNode: n.ProjectionNode
  };
}
export {
  W as createRendererMotionComponent
};
