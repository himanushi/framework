import { j as M } from "../../../../../../../../_virtual/jsx-runtime.js";
import { warning as E, invariant as g } from "../../../../motion-utils/dist/es/errors.js";
import { forwardRef as j, useContext as d } from "react";
import { LayoutGroupContext as L } from "../context/LayoutGroupContext.js";
import { LazyContext as N } from "../context/LazyContext.js";
import { MotionConfigContext as P } from "../context/MotionConfigContext.js";
import { MotionContext as b } from "../context/MotionContext/index.js";
import { useCreateMotionContext as w } from "../context/MotionContext/create.js";
import { isBrowser as C } from "../utils/is-browser.js";
import { featureDefinitions as S } from "./features/definitions.js";
import { loadFeatures as h } from "./features/load-features.js";
import { motionComponentSymbol as R } from "./utils/symbol.js";
import { useMotionRef as _ } from "./utils/use-motion-ref.js";
import { useVisualElement as k } from "./utils/use-visual-element.js";
function U({ preloadedFeatures: o, createVisualElement: t, useRender: e, useVisualState: n, Component: i }) {
  var u, m;
  o && h(o);
  function v(a, x) {
    let c;
    const s = {
      ...d(P),
      ...a,
      layoutId: z(a)
    }, { isStatic: l } = s, r = w(a), f = n(a, l);
    if (!l && C) {
      D(s, o);
      const p = G(s);
      c = p.MeasureLayout, r.visualElement = k(i, f, s, t, p.ProjectionNode);
    }
    return M.jsxs(b.Provider, { value: r, children: [c && r.visualElement ? M.jsx(c, { visualElement: r.visualElement, ...s }) : null, e(i, a, _(f, r.visualElement, x), f, l, r.visualElement)] });
  }
  v.displayName = `motion.${typeof i == "string" ? i : `create(${(m = (u = i.displayName) !== null && u !== void 0 ? u : i.name) !== null && m !== void 0 ? m : ""})`}`;
  const y = j(v);
  return y[R] = i, y;
}
function z({ layoutId: o }) {
  const t = d(L).id;
  return t && o !== void 0 ? t + "-" + o : o;
}
function D(o, t) {
  const e = d(N).strict;
  if (process.env.NODE_ENV !== "production" && t && e) {
    const n = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    o.ignoreStrict ? E(!1, n) : g(!1, n);
  }
}
function G(o) {
  const { drag: t, layout: e } = S;
  if (!t && !e)
    return {};
  const n = { ...t, ...e };
  return {
    MeasureLayout: t != null && t.isEnabled(o) || e != null && e.isEnabled(o) ? n.MeasureLayout : void 0,
    ProjectionNode: n.ProjectionNode
  };
}
export {
  U as createRendererMotionComponent
};
