import { invariant as w } from "../../../../../motion-utils/dist/es/errors.js";
import { millisecondsToSeconds as g, secondsToMilliseconds as x } from "../../../../../motion-utils/dist/es/time-conversion.js";
import { calcGeneratorDuration as G } from "../../../../../motion-dom/dist/es/animation/generators/utils/calc-duration.js";
import { isGenerator as O } from "../../../../../motion-dom/dist/es/animation/generators/utils/is-generator.js";
import { KeyframeResolver as I } from "../../render/utils/KeyframesResolver.js";
import { clamp as A } from "../../utils/clamp.js";
import { mix as B } from "../../utils/mix/index.js";
import { pipe as C } from "../../utils/pipe.js";
import { inertia as _ } from "../generators/inertia.js";
import { keyframes as p } from "../generators/keyframes.js";
import { spring as E } from "../generators/spring/index.js";
import { BaseAnimation as N } from "./BaseAnimation.js";
import { frameloopDriver as V } from "./drivers/driver-frameloop.js";
import { getFinalKeyframe as j } from "./waapi/utils/get-final-keyframe.js";
const U = {
  decay: _,
  inertia: _,
  tween: p,
  keyframes: p,
  spring: E
}, W = (P) => P / 100;
class nt extends N {
  constructor(t) {
    super(t), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: n } = this.options;
      n && n();
    };
    const { name: i, motionValue: r, element: e, keyframes: a } = this.options, u = (e == null ? void 0 : e.KeyframeResolver) || I, o = (n, l) => this.onKeyframesResolved(n, l);
    this.resolver = new u(a, o, i, r, e), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(t) {
    const { type: i = "keyframes", repeat: r = 0, repeatDelay: e = 0, repeatType: a, velocity: u = 0 } = this.options, o = O(i) ? i : U[i] || p;
    let n, l;
    process.env.NODE_ENV !== "production" && o !== p && w(t.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${t}`), o !== p && typeof t[0] != "number" && (n = C(W, B(t[0], t[1])), t = [0, 100]);
    const s = o({ ...this.options, keyframes: t });
    a === "mirror" && (l = o({
      ...this.options,
      keyframes: [...t].reverse(),
      velocity: -u
    })), s.calculatedDuration === null && (s.calculatedDuration = G(s));
    const { calculatedDuration: d } = s, f = d + e, T = f * (r + 1) - e;
    return {
      generator: s,
      mirroredGenerator: l,
      mapPercentToKeyframes: n,
      calculatedDuration: d,
      resolvedDuration: f,
      totalDuration: T
    };
  }
  onPostResolved() {
    const { autoplay: t = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !t ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(t, i = !1) {
    const { resolved: r } = this;
    if (!r) {
      const { keyframes: c } = this.options;
      return { done: !0, value: c[c.length - 1] };
    }
    const { finalKeyframe: e, generator: a, mirroredGenerator: u, mapPercentToKeyframes: o, keyframes: n, calculatedDuration: l, totalDuration: s, resolvedDuration: d } = r;
    if (this.startTime === null)
      return a.next(0);
    const { delay: f, repeat: T, repeatType: D, repeatDelay: S, onUpdate: k } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - s / this.speed, this.startTime)), i ? this.currentTime = t : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(t - this.startTime) * this.speed;
    const y = this.currentTime - f * (this.speed >= 0 ? 1 : -1), M = this.speed >= 0 ? y < 0 : y > s;
    this.currentTime = Math.max(y, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = s);
    let b = this.currentTime, K = a;
    if (T) {
      const c = Math.min(this.currentTime, s) / d;
      let v = Math.floor(c), h = c % 1;
      !h && c >= 1 && (h = 1), h === 1 && v--, v = Math.min(v, T + 1), !!(v % 2) && (D === "reverse" ? (h = 1 - h, S && (h -= S / d)) : D === "mirror" && (K = u)), b = A(0, 1, h) * d;
    }
    const m = M ? { done: !1, value: n[0] } : K.next(b);
    o && (m.value = o(m.value));
    let { done: F } = m;
    !M && l !== null && (F = this.speed >= 0 ? this.currentTime >= s : this.currentTime <= 0);
    const R = this.holdTime === null && (this.state === "finished" || this.state === "running" && F);
    return R && e !== void 0 && (m.value = j(n, this.options, e)), k && k(m.value), R && this.finish(), m;
  }
  get duration() {
    const { resolved: t } = this;
    return t ? g(t.calculatedDuration) : 0;
  }
  get time() {
    return g(this.currentTime);
  }
  set time(t) {
    t = x(t), this.currentTime = t, this.holdTime !== null || this.speed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    const i = this.playbackSpeed !== t;
    this.playbackSpeed = t, i && (this.time = g(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: t = V, onPlay: i, startTime: r } = this.options;
    this.driver || (this.driver = t((a) => this.tick(a))), i && i();
    const e = this.driver.now();
    this.holdTime !== null ? this.startTime = e - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = e) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var t;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (t = this.currentTime) !== null && t !== void 0 ? t : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: t } = this.options;
    t && t();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
}
export {
  nt as MainThreadAnimation
};
