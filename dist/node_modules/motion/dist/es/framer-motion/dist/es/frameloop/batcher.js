import { stepsOrder as c } from "./order.js";
import { createRenderStep as M } from "./render-step.js";
const w = 40;
function S(o, p) {
  let r = !1, a = !0;
  const e = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, l = () => r = !0, n = c.reduce((s, t) => (s[t] = M(l, p ? t : void 0), s), {}), { read: u, resolveKeyframes: f, update: m, preRender: d, render: g, postRender: h } = n, i = () => {
    const s = performance.now();
    r = !1, e.delta = a ? 1e3 / 60 : Math.max(Math.min(s - e.timestamp, w), 1), e.timestamp = s, e.isProcessing = !0, u.process(e), f.process(e), m.process(e), d.process(e), g.process(e), h.process(e), e.isProcessing = !1, r && p && (a = !1, o(i));
  }, R = () => {
    r = !0, a = !0, e.isProcessing || o(i);
  };
  return { schedule: c.reduce((s, t) => {
    const x = n[t];
    return s[t] = (P, E = !1, F = !1) => (r || R(), x.schedule(P, E, F)), s;
  }, {}), cancel: (s) => {
    for (let t = 0; t < c.length; t++)
      n[c[t]].cancel(s);
  }, state: e, steps: n };
}
export {
  S as createRenderBatcher
};
