import { noop as y } from "../../../../../motion-utils/dist/es/noop.js";
import { millisecondsToSeconds as g, secondsToMilliseconds as T } from "../../../../../motion-utils/dist/es/time-conversion.js";
import { isGenerator as V } from "../../../../../motion-dom/dist/es/animation/generators/utils/is-generator.js";
import { attachTimeline as w } from "../../../../../motion-dom/dist/es/animation/waapi/utils/attach-timeline.js";
import { isWaapiSupportedEasing as F } from "../../../../../motion-dom/dist/es/animation/waapi/utils/easing.js";
import { supportsLinearEasing as K } from "../../../../../motion-dom/dist/es/utils/supports/linear-easing.js";
import { anticipate as E } from "../../easing/anticipate.js";
import { backInOut as R } from "../../easing/back.js";
import { circInOut as b } from "../../easing/circ.js";
import { DOMKeyframesResolver as D } from "../../render/dom/DOMKeyframesResolver.js";
import { BaseAnimation as M } from "./BaseAnimation.js";
import { MainThreadAnimation as S } from "./MainThreadAnimation.js";
import { acceleratedValues as U } from "./utils/accelerated-values.js";
import { startWaapiAnimation as W } from "./waapi/index.js";
import { getFinalKeyframe as x } from "./waapi/utils/get-final-keyframe.js";
import { supportsWaapi as C } from "./waapi/utils/supports-waapi.js";
const f = 10, G = 2e4;
function O(r) {
  return V(r.type) || r.type === "spring" || !F(r.ease);
}
function k(r, e) {
  const t = new S({
    ...e,
    keyframes: r,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let i = { done: !1, value: r[0] };
  const s = [];
  let n = 0;
  for (; !i.done && n < G; )
    i = t.sample(n), s.push(i.value), n += f;
  return {
    times: void 0,
    keyframes: s,
    duration: n - f,
    ease: "linear"
  };
}
const A = {
  anticipate: E,
  backInOut: R,
  circInOut: b
};
function I(r) {
  return r in A;
}
class ie extends M {
  constructor(e) {
    super(e);
    const { name: t, motionValue: i, element: s, keyframes: n } = this.options;
    this.resolver = new D(n, (a, o) => this.onKeyframesResolved(a, o), t, i, s), this.resolver.scheduleResolve();
  }
  initPlayback(e, t) {
    let { duration: i = 300, times: s, ease: n, type: a, motionValue: o, name: p, startTime: m } = this.options;
    if (!o.owner || !o.owner.current)
      return !1;
    if (typeof n == "string" && K() && I(n) && (n = A[n]), O(this.options)) {
      const { onComplete: c, onUpdate: P, motionValue: v, element: h, ...u } = this.options, d = k(e, u);
      e = d.keyframes, e.length === 1 && (e[1] = e[0]), i = d.duration, s = d.times, n = d.ease, a = "keyframes";
    }
    const l = W(o.owner.current, p, e, { ...this.options, duration: i, times: s, ease: n });
    return l.startTime = m ?? this.calcStartTime(), this.pendingTimeline ? (w(l, this.pendingTimeline), this.pendingTimeline = void 0) : l.onfinish = () => {
      const { onComplete: c } = this.options;
      o.set(x(e, this.options, t)), c && c(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: l,
      duration: i,
      times: s,
      type: a,
      ease: n,
      keyframes: e
    };
  }
  get duration() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { duration: t } = e;
    return g(t);
  }
  get time() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { animation: t } = e;
    return g(t.currentTime || 0);
  }
  set time(e) {
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: i } = t;
    i.currentTime = T(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e)
      return 1;
    const { animation: t } = e;
    return t.playbackRate;
  }
  set speed(e) {
    const { resolved: t } = this;
    if (!t)
      return;
    const { animation: i } = t;
    i.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e)
      return "idle";
    const { animation: t } = e;
    return t.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e)
      return null;
    const { animation: t } = e;
    return t.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(e) {
    if (!this._resolved)
      this.pendingTimeline = e;
    else {
      const { resolved: t } = this;
      if (!t)
        return y;
      const { animation: i } = t;
      w(i, e);
    }
    return y;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: t } = e;
    t.playState === "finished" && this.updateFinishedPromise(), t.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: t } = e;
    t.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: t, keyframes: i, duration: s, type: n, ease: a, times: o } = e;
    if (t.playState === "idle" || t.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: m, onUpdate: l, onComplete: c, element: P, ...v } = this.options, h = new S({
        ...v,
        keyframes: i,
        duration: s,
        type: n,
        ease: a,
        times: o,
        isGenerator: !0
      }), u = T(this.time);
      m.setWithVelocity(h.sample(u - f).value, h.sample(u).value, f);
    }
    const { onStop: p } = this.options;
    p && p(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const { motionValue: t, name: i, repeatDelay: s, repeatType: n, damping: a, type: o } = e;
    if (!t || !t.owner || !(t.owner.current instanceof HTMLElement))
      return !1;
    const { onUpdate: p, transformTemplate: m } = t.owner.getProps();
    return C() && i && U.has(i) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !p && !m && !s && n !== "mirror" && a !== 0 && o !== "inertia";
  }
}
export {
  ie as AcceleratedAnimation
};
