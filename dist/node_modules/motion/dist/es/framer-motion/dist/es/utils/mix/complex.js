import { mixNumber as h } from "./number.js";
import { mixColor as u } from "./color.js";
import { pipe as b } from "../pipe.js";
import { warning as y } from "../../../../../motion-utils/dist/es/errors.js";
import { color as m } from "../../value/types/color/index.js";
import { complex as v, analyseComplexValue as a } from "../../value/types/complex/index.js";
import { isCSSVariableToken as g } from "../../render/dom/utils/is-css-variable.js";
import { invisibleValues as c, mixVisibility as V } from "./visibility.js";
import { mixImmediate as l } from "./immediate.js";
function C(e, t) {
  return (r) => h(e, t, r);
}
function f(e) {
  return typeof e == "number" ? C : typeof e == "string" ? g(e) ? l : m.test(e) ? u : S : Array.isArray(e) ? p : typeof e == "object" ? m.test(e) ? u : k : l;
}
function p(e, t) {
  const r = [...e], o = r.length, n = e.map((i, s) => f(i)(i, t[s]));
  return (i) => {
    for (let s = 0; s < o; s++)
      r[s] = n[s](i);
    return r;
  };
}
function k(e, t) {
  const r = { ...e, ...t }, o = {};
  for (const n in r)
    e[n] !== void 0 && t[n] !== void 0 && (o[n] = f(e[n])(e[n], t[n]));
  return (n) => {
    for (const i in o)
      r[i] = o[i](n);
    return r;
  };
}
function I(e, t) {
  var r;
  const o = [], n = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < t.values.length; i++) {
    const s = t.types[i], x = e.indexes[s][n[s]], d = (r = e.values[x]) !== null && r !== void 0 ? r : 0;
    o[i] = d, n[s]++;
  }
  return o;
}
const S = (e, t) => {
  const r = v.createTransformer(t), o = a(e), n = a(t);
  return o.indexes.var.length === n.indexes.var.length && o.indexes.color.length === n.indexes.color.length && o.indexes.number.length >= n.indexes.number.length ? c.has(e) && !n.values.length || c.has(t) && !o.values.length ? V(e, t) : b(p(I(o, n), n.values), r) : (y(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), l(e, t));
};
export {
  f as getMixer,
  p as mixArray,
  S as mixComplex,
  k as mixObject
};
