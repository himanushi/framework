import { invariant as L } from "../../../../../motion-utils/dist/es/errors.js";
import { setDragLock as M } from "../../../../../motion-dom/dist/es/gestures/drag/state/set-active.js";
import { PanSession as S } from "../pan/PanSession.js";
import { isRefObject as D } from "../../utils/is-ref-object.js";
import { addPointerEvent as B } from "../../events/add-pointer-event.js";
import { applyConstraints as k, calcRelativeConstraints as j, resolveDragElastic as T, calcViewportConstraints as w, defaultElastic as b, rebaseAxisConstraints as R, calcOrigin as W } from "./utils/constraints.js";
import { createBox as _ } from "../../projection/geometry/models.js";
import { eachAxis as u } from "../../projection/utils/each-axis.js";
import { measurePageBox as O } from "../../projection/utils/measure.js";
import { extractEventInfo as U } from "../../events/event-info.js";
import { convertBoxToBoundingBox as z, convertBoundingBoxToBox as I } from "../../projection/geometry/conversion.js";
import { addDomEvent as F } from "../../events/add-dom-event.js";
import { calcLength as K } from "../../projection/geometry/delta-calc.js";
import { mixNumber as V } from "../../utils/mix/number.js";
import { percent as N } from "../../value/types/numbers/units.js";
import { animateMotionValue as $ } from "../../animation/interfaces/motion-value.js";
import { getContextWindow as q } from "../../utils/get-context-window.js";
import { addValueToWillChange as x } from "../../value/use-will-change/add-will-change.js";
import { frame as C } from "../../frameloop/frame.js";
const G = /* @__PURE__ */ new WeakMap();
class ft {
  constructor(t) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = _(), this.visualElement = t;
  }
  start(t, { snapToCursor: s = !1 } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1)
      return;
    const n = (o) => {
      const { dragSnapToOrigin: a } = this.getProps();
      a ? this.pauseAnimation() : this.stopAnimation(), s && this.snapToCursor(U(o).point);
    }, r = (o, a) => {
      const { drag: f, dragPropagation: d, onDragStart: g } = this.getProps();
      if (f && !d && (this.openDragLock && this.openDragLock(), this.openDragLock = M(f), !this.openDragLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), u((m) => {
        let E = this.getAxisMotionValue(m).get() || 0;
        if (N.test(E)) {
          const { projection: A } = this.visualElement;
          if (A && A.layout) {
            const y = A.layout.layoutBox[m];
            y && (E = K(y) * (parseFloat(E) / 100));
          }
        }
        this.originPoint[m] = E;
      }), g && C.postRender(() => g(o, a)), x(this.visualElement, "transform");
      const { animationState: v } = this.visualElement;
      v && v.setActive("whileDrag", !0);
    }, e = (o, a) => {
      const { dragPropagation: f, dragDirectionLock: d, onDirectionLock: g, onDrag: v } = this.getProps();
      if (!f && !this.openDragLock)
        return;
      const { offset: m } = a;
      if (d && this.currentDirection === null) {
        this.currentDirection = H(m), this.currentDirection !== null && g && g(this.currentDirection);
        return;
      }
      this.updateAxis("x", a.point, m), this.updateAxis("y", a.point, m), this.visualElement.render(), v && v(o, a);
    }, l = (o, a) => this.stop(o, a), c = () => u((o) => {
      var a;
      return this.getAnimationState(o) === "paused" && ((a = this.getAxisMotionValue(o).animation) === null || a === void 0 ? void 0 : a.play());
    }), { dragSnapToOrigin: h } = this.getProps();
    this.panSession = new S(t, {
      onSessionStart: n,
      onStart: r,
      onMove: e,
      onSessionEnd: l,
      resumeAnimation: c
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: h,
      contextWindow: q(this.visualElement)
    });
  }
  stop(t, s) {
    const i = this.isDragging;
    if (this.cancel(), !i)
      return;
    const { velocity: n } = s;
    this.startAnimation(n);
    const { onDragEnd: r } = this.getProps();
    r && C.postRender(() => r(t, s));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: s } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: i } = this.getProps();
    !i && this.openDragLock && (this.openDragLock(), this.openDragLock = null), s && s.setActive("whileDrag", !1);
  }
  updateAxis(t, s, i) {
    const { drag: n } = this.getProps();
    if (!i || !P(t, n, this.currentDirection))
      return;
    const r = this.getAxisMotionValue(t);
    let e = this.originPoint[t] + i[t];
    this.constraints && this.constraints[t] && (e = k(e, this.constraints[t], this.elastic[t])), r.set(e);
  }
  resolveConstraints() {
    var t;
    const { dragConstraints: s, dragElastic: i } = this.getProps(), n = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) === null || t === void 0 ? void 0 : t.layout, r = this.constraints;
    s && D(s) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : s && n ? this.constraints = j(n.layoutBox, s) : this.constraints = !1, this.elastic = T(i), r !== this.constraints && n && this.constraints && !this.hasMutatedConstraints && u((e) => {
      this.constraints !== !1 && this.getAxisMotionValue(e) && (this.constraints[e] = R(n.layoutBox[e], this.constraints[e]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: s } = this.getProps();
    if (!t || !D(t))
      return !1;
    const i = t.current;
    L(i !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: n } = this.visualElement;
    if (!n || !n.layout)
      return !1;
    const r = O(i, n.root, this.visualElement.getTransformPagePoint());
    let e = w(n.layout.layoutBox, r);
    if (s) {
      const l = s(z(e));
      this.hasMutatedConstraints = !!l, l && (e = I(l));
    }
    return e;
  }
  startAnimation(t) {
    const { drag: s, dragMomentum: i, dragElastic: n, dragTransition: r, dragSnapToOrigin: e, onDragTransitionEnd: l } = this.getProps(), c = this.constraints || {}, h = u((o) => {
      if (!P(o, s, this.currentDirection))
        return;
      let a = c && c[o] || {};
      e && (a = { min: 0, max: 0 });
      const f = n ? 200 : 1e6, d = n ? 40 : 1e7, g = {
        type: "inertia",
        velocity: i ? t[o] : 0,
        bounceStiffness: f,
        bounceDamping: d,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...r,
        ...a
      };
      return this.startAxisValueAnimation(o, g);
    });
    return Promise.all(h).then(l);
  }
  startAxisValueAnimation(t, s) {
    const i = this.getAxisMotionValue(t);
    return x(this.visualElement, t), i.start($(t, i, 0, s, this.visualElement, !1));
  }
  stopAnimation() {
    u((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    u((t) => {
      var s;
      return (s = this.getAxisMotionValue(t).animation) === null || s === void 0 ? void 0 : s.pause();
    });
  }
  getAnimationState(t) {
    var s;
    return (s = this.getAxisMotionValue(t).animation) === null || s === void 0 ? void 0 : s.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const s = `_drag${t.toUpperCase()}`, i = this.visualElement.getProps(), n = i[s];
    return n || this.visualElement.getValue(t, (i.initial ? i.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    u((s) => {
      const { drag: i } = this.getProps();
      if (!P(s, i, this.currentDirection))
        return;
      const { projection: n } = this.visualElement, r = this.getAxisMotionValue(s);
      if (n && n.layout) {
        const { min: e, max: l } = n.layout.layoutBox[s];
        r.set(t[s] - V(e, l, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: s } = this.getProps(), { projection: i } = this.visualElement;
    if (!D(s) || !i || !this.constraints)
      return;
    this.stopAnimation();
    const n = { x: 0, y: 0 };
    u((e) => {
      const l = this.getAxisMotionValue(e);
      if (l && this.constraints !== !1) {
        const c = l.get();
        n[e] = W({ min: c, max: c }, this.constraints[e]);
      }
    });
    const { transformTemplate: r } = this.visualElement.getProps();
    this.visualElement.current.style.transform = r ? r({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), u((e) => {
      if (!P(e, t, null))
        return;
      const l = this.getAxisMotionValue(e), { min: c, max: h } = this.constraints[e];
      l.set(V(c, h, n[e]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    G.set(this.visualElement, this);
    const t = this.visualElement.current, s = B(t, "pointerdown", (c) => {
      const { drag: h, dragListener: o = !0 } = this.getProps();
      h && o && this.start(c);
    }), i = () => {
      const { dragConstraints: c } = this.getProps();
      D(c) && c.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: n } = this.visualElement, r = n.addEventListener("measure", i);
    n && !n.layout && (n.root && n.root.updateScroll(), n.updateLayout()), C.read(i);
    const e = F(window, "resize", () => this.scalePositionWithinConstraints()), l = n.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: h }) => {
      this.isDragging && h && (u((o) => {
        const a = this.getAxisMotionValue(o);
        a && (this.originPoint[o] += c[o].translate, a.set(a.get() + c[o].translate));
      }), this.visualElement.render());
    });
    return () => {
      e(), s(), r(), l && l();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: s = !1, dragDirectionLock: i = !1, dragPropagation: n = !1, dragConstraints: r = !1, dragElastic: e = b, dragMomentum: l = !0 } = t;
    return {
      ...t,
      drag: s,
      dragDirectionLock: i,
      dragPropagation: n,
      dragConstraints: r,
      dragElastic: e,
      dragMomentum: l
    };
  }
}
function P(p, t, s) {
  return (t === !0 || t === p) && (s === null || s === p);
}
function H(p, t = 10) {
  let s = null;
  return Math.abs(p.y) > t ? s = "y" : Math.abs(p.x) > t && (s = "x"), s;
}
export {
  ft as VisualElementDragControls,
  G as elementDragControls
};
