import { jsx as f } from "react/jsx-runtime";
import * as C from "react";
import { useId as M, useCallback as v, useMemo as c } from "react";
import { PresenceContext as w } from "../../context/PresenceContext.js";
import { useConstant as x } from "../../utils/use-constant.js";
import { PopChild as z } from "./PopChild.js";
const O = ({ children: n, initial: m, isPresent: r, onExitComplete: o, custom: u, presenceAffectsLayout: i, mode: p, anchorX: l }) => {
  const e = x(b), d = M(), s = v((t) => {
    e.set(t, !0);
    for (const a of e.values())
      if (!a)
        return;
    o && o();
  }, [e, o]), h = c(
    () => ({
      id: d,
      initial: m,
      isPresent: r,
      custom: u,
      onExitComplete: s,
      register: (t) => (e.set(t, !1), () => e.delete(t))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    i ? [Math.random(), s] : [r, s]
  );
  return c(() => {
    e.forEach((t, a) => e.set(a, !1));
  }, [r]), C.useEffect(() => {
    !r && !e.size && o && o();
  }, [r]), p === "popLayout" && (n = f(z, { isPresent: r, anchorX: l, children: n })), f(w.Provider, { value: h, children: n });
};
function b() {
  return /* @__PURE__ */ new Map();
}
export {
  O as PresenceChild
};
