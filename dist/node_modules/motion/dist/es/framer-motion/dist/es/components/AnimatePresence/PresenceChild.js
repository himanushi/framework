import { j as f } from "../../../../../../../../../_virtual/jsx-runtime.js";
import * as C from "react";
import { useId as x, useCallback as j, useMemo as m } from "react";
import { PresenceContext as M } from "../../context/PresenceContext.js";
import { useConstant as v } from "../../utils/use-constant.js";
import { PopChild as w } from "./PopChild.js";
const E = ({ children: s, initial: c, isPresent: r, onExitComplete: o, custom: u, presenceAffectsLayout: i, mode: p, anchorX: l }) => {
  const e = v(z), d = x(), n = j((t) => {
    e.set(t, !0);
    for (const a of e.values())
      if (!a)
        return;
    o && o();
  }, [e, o]), h = m(
    () => ({
      id: d,
      initial: c,
      isPresent: r,
      custom: u,
      onExitComplete: n,
      register: (t) => (e.set(t, !1), () => e.delete(t))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    i ? [Math.random(), n] : [r, n]
  );
  return m(() => {
    e.forEach((t, a) => e.set(a, !1));
  }, [r]), C.useEffect(() => {
    !r && !e.size && o && o();
  }, [r]), p === "popLayout" && (s = f.jsx(w, { isPresent: r, anchorX: l, children: s })), f.jsx(M.Provider, { value: h, children: s });
};
function z() {
  return /* @__PURE__ */ new Map();
}
export {
  E as PresenceChild
};
